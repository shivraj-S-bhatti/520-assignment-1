{"ts": 1761278704.714893, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "cosine_similarity", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Cosine Similarity\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef cosine_similarity(a: List[float], b: List[float]) -> float:\n```\n\n**Task:** Compute cosine similarity between two equal-length vectors.\n\n**Details & Constraints:**\n\nReturn 0.0 if either vector has zero magnitude. Use float return. Raise ValueError if lengths differ.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278720.102608, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "evaluate_rpn", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Evaluate Reverse Polish Notation\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef evaluate_rpn(tokens: List[str]) -> int:\n```\n\n**Task:** Evaluate an RPN expression with +, -, *, / (truncating toward zero).\n\n**Details & Constraints:**\n\nSupported tokens are integers and operators + - * /. Division truncates toward zero like int(a/b).\nRaise ValueError for invalid expressions (e.g., too few operands or division by zero).\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278735.200216, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "int_to_roman", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Integer to Roman\n\n**Function signature:**\n\n```python\ndef int_to_roman(n: int) -> str:\n```\n\n**Task:** Convert an integer to Roman numerals (1..3999).\n\n**Details & Constraints:**\n\nReturn the Roman numeral representation of n for 1 <= n <= 3999.\nRaise ValueError for out-of-range inputs.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278749.89107, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "is_palindrome_sentence", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Sentence Palindrome\n\n**Function signature:**\n\n```python\ndef is_palindrome_sentence(s: str) -> bool:\n```\n\n**Task:** Check if a string is a palindrome ignoring non-alphanumeric characters and case.\n\n**Details & Constraints:**\n\nReturn True if s reads the same forward and backward considering only [A-Za-z0-9], case-insensitive; else False.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278765.8054779, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "merge_intervals", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Merge Intervals\n\n**Function signature:**\n\n```python\nfrom typing import List, Tuple\n\ndef merge_intervals(intervals: List[Tuple[int,int]]) -> List[Tuple[int,int]]:\n```\n\n**Task:** Merge overlapping intervals.\n\n**Details & Constraints:**\n\nGiven a list of (start, end) with start <= end, merge all overlapping intervals and return a list sorted by start.\nEmpty input returns empty list.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278783.6160982, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "min_window_substring", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Minimum Window Substring\n\n**Function signature:**\n\n```python\ndef min_window_substring(s: str, t: str) -> str:\n```\n\n**Task:** Return the smallest substring of s containing all characters of t (with multiplicity).\n\n**Details & Constraints:**\n\nIf no such window exists, return ''. Characters are ASCII. Complexity must be O(|s| + |t|) on average.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278802.637015, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "normalize_path", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Normalize a Unix-style path\n\n**Function signature:**\n\n```python\ndef normalize_path(path: str) -> str:\n```\n\n**Task:** Given a Unix-style path string, return its normalized form by resolving '.', '..' and redundant slashes. Preserve absolute vs relative semantics.\n\n**Details & Constraints:**\n\nRules:\n- Multiple '/' collapse to a single '/'.\n- '.' means current directory, skip it.\n- '..' pops one segment unless at root for absolute paths (then stay at '/'). For relative paths, leading '..' should be preserved.\n- Preserve a trailing slash only if the normalized path is root '/'.\nExamples:\n- '/a//b/./c/../' -> '/a/b/'\n- 'a/b/../../c' -> 'c'\n- '../../x' -> '../../x'\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278818.81319, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "parse_csv_line", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Parse CSV Line\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n```\n\n**Task:** Parse a single CSV line into fields.\n\n**Details & Constraints:**\n\nRules (RFC 4180 subset):\n- Fields separated by commas.\n- Fields may be quoted with double quotes.\n- Inside quoted fields, double-double-quotes \"\" represent a literal quote.\n- Commas inside quoted fields do not split.\n- Leading/trailing spaces are preserved unless inside quotes.\n- Empty line -> ['']\nExamples:\n- 'a,b,\"c,d\"' -> ['a','b','c,d']\n- '\"a\"\"b\",c' -> ['a\"b','c']\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278834.455895, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "sudoku_is_valid", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Validate Sudoku Board\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef sudoku_is_valid(board: List[List[str]]) -> bool:\n```\n\n**Task:** Check whether a partially filled 9x9 Sudoku board is valid.\n\n**Details & Constraints:**\n\nBoard uses '.' for empty and '1'-'9' for digits. Check rows, columns, and 3x3 boxes for duplicates (ignoring '.').\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278849.146979, "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "problem": "top_k_frequent", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Top-K Frequent Elements\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n```\n\n**Task:** Return the k most frequent integers in nums.\n\n**Details & Constraints:**\n\nIf frequencies tie, break ties by smaller integer first. Output length must be exactly k. Raise ValueError if k < 1 or k > number of unique elements.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278859.654676, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "cosine_similarity", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Cosine Similarity\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef cosine_similarity(a: List[float], b: List[float]) -> float:\n```\n\n**Task:** Compute cosine similarity between two equal-length vectors.\n\n**Details & Constraints:**\n\nReturn 0.0 if either vector has zero magnitude. Use float return. Raise ValueError if lengths differ.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278869.296375, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "evaluate_rpn", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Evaluate Reverse Polish Notation\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef evaluate_rpn(tokens: List[str]) -> int:\n```\n\n**Task:** Evaluate an RPN expression with +, -, *, / (truncating toward zero).\n\n**Details & Constraints:**\n\nSupported tokens are integers and operators + - * /. Division truncates toward zero like int(a/b).\nRaise ValueError for invalid expressions (e.g., too few operands or division by zero).\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278880.82993, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "int_to_roman", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Integer to Roman\n\n**Function signature:**\n\n```python\ndef int_to_roman(n: int) -> str:\n```\n\n**Task:** Convert an integer to Roman numerals (1..3999).\n\n**Details & Constraints:**\n\nReturn the Roman numeral representation of n for 1 <= n <= 3999.\nRaise ValueError for out-of-range inputs.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278890.335574, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "is_palindrome_sentence", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Sentence Palindrome\n\n**Function signature:**\n\n```python\ndef is_palindrome_sentence(s: str) -> bool:\n```\n\n**Task:** Check if a string is a palindrome ignoring non-alphanumeric characters and case.\n\n**Details & Constraints:**\n\nReturn True if s reads the same forward and backward considering only [A-Za-z0-9], case-insensitive; else False.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278901.606853, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "merge_intervals", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Merge Intervals\n\n**Function signature:**\n\n```python\nfrom typing import List, Tuple\n\ndef merge_intervals(intervals: List[Tuple[int,int]]) -> List[Tuple[int,int]]:\n```\n\n**Task:** Merge overlapping intervals.\n\n**Details & Constraints:**\n\nGiven a list of (start, end) with start <= end, merge all overlapping intervals and return a list sorted by start.\nEmpty input returns empty list.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278915.603668, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "min_window_substring", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Minimum Window Substring\n\n**Function signature:**\n\n```python\ndef min_window_substring(s: str, t: str) -> str:\n```\n\n**Task:** Return the smallest substring of s containing all characters of t (with multiplicity).\n\n**Details & Constraints:**\n\nIf no such window exists, return ''. Characters are ASCII. Complexity must be O(|s| + |t|) on average.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278925.390399, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "normalize_path", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Normalize a Unix-style path\n\n**Function signature:**\n\n```python\ndef normalize_path(path: str) -> str:\n```\n\n**Task:** Given a Unix-style path string, return its normalized form by resolving '.', '..' and redundant slashes. Preserve absolute vs relative semantics.\n\n**Details & Constraints:**\n\nRules:\n- Multiple '/' collapse to a single '/'.\n- '.' means current directory, skip it.\n- '..' pops one segment unless at root for absolute paths (then stay at '/'). For relative paths, leading '..' should be preserved.\n- Preserve a trailing slash only if the normalized path is root '/'.\nExamples:\n- '/a//b/./c/../' -> '/a/b/'\n- 'a/b/../../c' -> 'c'\n- '../../x' -> '../../x'\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278944.5826719, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "parse_csv_line", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Parse CSV Line\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n```\n\n**Task:** Parse a single CSV line into fields.\n\n**Details & Constraints:**\n\nRules (RFC 4180 subset):\n- Fields separated by commas.\n- Fields may be quoted with double quotes.\n- Inside quoted fields, double-double-quotes \"\" represent a literal quote.\n- Commas inside quoted fields do not split.\n- Leading/trailing spaces are preserved unless inside quotes.\n- Empty line -> ['']\nExamples:\n- 'a,b,\"c,d\"' -> ['a','b','c,d']\n- '\"a\"\"b\",c' -> ['a\"b','c']\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278957.669621, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "sudoku_is_valid", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Validate Sudoku Board\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef sudoku_is_valid(board: List[List[str]]) -> bool:\n```\n\n**Task:** Check whether a partially filled 9x9 Sudoku board is valid.\n\n**Details & Constraints:**\n\nBoard uses '.' for empty and '1'-'9' for digits. Check rows, columns, and 3x3 boxes for duplicates (ignoring '.').\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
{"ts": 1761278969.836243, "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "problem": "top_k_frequent", "prompt": "**Instruction to model:**\n> You are a senior Python engineer. Think step-by-step about edge cases and the algorithm. Then implement the function.\n\n**Prompt:**\n```\n# Top-K Frequent Elements\n\n**Function signature:**\n\n```python\nfrom typing import List\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n```\n\n**Task:** Return the k most frequent integers in nums.\n\n**Details & Constraints:**\n\nIf frequencies tie, break ties by smaller integer first. Output length must be exactly k. Raise ValueError if k < 1 or k > number of unique elements.\n\n\nRequirements:\n- Implement only the required function with the exact signature.\n- Include a brief docstring that lists handled edge-cases.\n- Return only a Python code block; no prose.\n\nLet's reason step-by-step, then write the code.\n```"}
