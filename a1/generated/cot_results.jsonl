{"ts": 1761278704.716074, "problem": "cosine_similarity", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\nimport math\n\ndef cosine_similarity(a: List[float], b: List[float]) -> float:\n    \"\"\"\n    Compute cosine similarity between two equal-length vectors.\n\n    Returns 0.0 if either vector has zero magnitude.\n    Raises ValueError if lengths differ.\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must have the same length\")\n\n    dot_product = sum(x * y for x, y in zip(a, b))\n    magnitude_a = math.sqrt(sum(x ** 2 for x in a))\n    magnitude_b = math.sqrt(sum(x ** 2 for x in b))\n\n    if magnitude_a == 0.0 or magnitude_b == 0.0:\n        return 0.0\n\n    return dot_product / (magnitude_a * magnitude_b)", "passed": true, "failures": []}]}
{"ts": 1761278720.103619, "problem": "evaluate_rpn", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\n\ndef evaluate_rpn(tokens: List[str]) -> int:\n    \"\"\"Evaluates an RPN expression.\n\n    Handles edge cases:\n    - Invalid input (e.g., insufficient operands, division by zero).\n    - Returns integer after truncation towards zero.\n    \"\"\"\n    stack = []\n    operators = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"*\": lambda a, b: a * b,\n        \"/\": lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n        if token in operators:\n            if len(stack) < 2:\n                raise ValueError(\"Insufficient operands\")\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            try:\n                result = operators[token](operand1, operand2)\n                stack.append(result)\n            except ZeroDivisionError:\n                raise ValueError(\"Division by zero\")\n        else:\n            try:\n                stack.append(int(token))\n            except ValueError:\n                raise ValueError(f\"Invalid token: {token}\")\n\n    if len(stack) != 1:\n        raise ValueError(\"Invalid expression: Too many operands\")\n\n    return stack[0]", "passed": true, "failures": []}]}
{"ts": 1761278735.201666, "problem": "int_to_roman", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def int_to_roman(n: int) -> str:\n    \"\"\"\n    Convert an integer to Roman numerals (1..3999).\n\n    Raises ValueError for out-of-range inputs.\n    \"\"\"\n    if not 1 <= n <= 3999:\n        raise ValueError(\"Input must be between 1 and 3999\")\n\n    roman_map = {\n        1: \"I\",\n        4: \"IV\",\n        5: \"V\",\n        9: \"IX\",\n        10: \"X\",\n        40: \"XL\",\n        50: \"L\",\n        90: \"XC\",\n        100: \"C\",\n        400: \"CD\",\n        500: \"D\",\n        900: \"CM\",\n        1000: \"M\",\n    }\n\n    integers = list(roman_map.keys())\n    integers.sort(reverse=True)\n\n    result = \"\"\n    for i in integers:\n        while n >= i:\n            result += roman_map[i]\n            n -= i\n\n    return result", "passed": true, "failures": []}]}
{"ts": 1761278749.8925729, "problem": "is_palindrome_sentence", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def is_palindrome_sentence(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome ignoring non-alphanumeric characters and case.\n\n    Edge cases:\n    - Empty string: returns True\n    - String with only non-alphanumeric characters: returns True\n    - String with mixed alphanumeric and non-alphanumeric characters.\n    \"\"\"\n    filtered_string = ''.join(ch.lower() for ch in s if ch.isalnum())\n    left = 0\n    right = len(filtered_string) - 1\n\n    while left < right:\n        if filtered_string[left] != filtered_string[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True", "passed": true, "failures": []}]}
{"ts": 1761278765.806876, "problem": "merge_intervals", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List, Tuple\n\ndef merge_intervals(intervals: List[Tuple[int,int]]) -> List[Tuple[int,int]]:\n    \"\"\"\n    Merges overlapping intervals.\n\n    Handles edge cases:\n    - Empty input list.\n    - Non-overlapping intervals.\n    - Overlapping intervals.\n    - Intervals fully contained within other intervals.\n    \"\"\"\n    if not intervals:\n        return []\n\n    intervals.sort()  # Sort by start time\n\n    merged_intervals = []\n    for interval in intervals:\n        # If the list of merged intervals is empty or if the current\n        # interval does not overlap with the last interval, append it.\n        if not merged_intervals or interval[0] > merged_intervals[-1][1]:\n            merged_intervals.append(interval)\n        else:\n            # Otherwise, there is overlap, so we merge the current and previous\n            # intervals.\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1]))\n\n    return merged_intervals", "passed": true, "failures": []}]}
{"ts": 1761278783.61747, "problem": "min_window_substring", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def min_window_substring(s: str, t: str) -> str:\n    \"\"\"\n    Finds the smallest substring of s containing all characters of t (with multiplicity).\n\n    Edge cases:\n    - t is empty: return \"\"\n    - s is empty: return \"\" if t is not empty; otherwise return \"\"\n    - t is longer than s: return \"\"\n    - s does not contain all characters of t: return \"\"\n    - s is equal to t: return s\n    - s and t contain duplicate characters.\n    \"\"\"\n    if not t:\n        return \"\"\n    if not s:\n        return \"\"\n    if len(t) > len(s):\n        return \"\"\n\n    t_freq = {}\n    for char in t:\n        t_freq[char] = t_freq.get(char, 0) + 1\n\n    window_freq = {}\n    left = 0\n    right = 0\n    min_len = float('inf')\n    min_start = 0\n    matched = 0\n\n    while right < len(s):\n        char = s[right]\n        window_freq[char] = window_freq.get(char, 0) + 1\n\n        if char in t_freq and window_freq[char] == t_freq[char]:\n            matched += 1\n\n        while matched == len(t_freq):\n            if (right - left + 1) < min_len:\n                min_len = right - left + 1\n                min_start = left\n\n            left_char = s[left]\n            window_freq[left_char] -= 1\n\n            if left_char in t_freq and window_freq[left_char] < t_freq[left_char]:\n                matched -= 1\n\n            left += 1\n\n        right += 1\n\n    if min_len == float('inf'):\n        return \"\"\n    else:\n        return s[min_start:min_start + min_len]", "passed": true, "failures": []}]}
{"ts": 1761278802.638036, "problem": "normalize_path", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 0, "pass_at_k": 0.0, "history": [{"code": "def normalize_path(path: str) -> str:\n    \"\"\"Normalize a Unix-style path, handling '.', '..', and redundant slashes.\n\n    Edge cases handled:\n    - Multiple slashes.\n    - Current directory ('.').\n    - Parent directory ('..') for both absolute and relative paths.\n    - Root path ('/').\n    - Trailing slashes (preserved only for root).\n    \"\"\"\n    is_absolute = path.startswith('/')\n    components = path.split('/')\n    stack = []\n\n    for component in components:\n        if not component or component == '.':\n            continue\n        elif component == '..':\n            if stack and (not is_absolute or stack[-1] != ''): #check if last element is \"\" so we can't pop off \"/\"\n                stack.pop()\n            elif is_absolute:\n                pass # at root, so stay at root, do nothing\n            else:\n                if not stack:\n                    stack.append('..')\n                elif stack[-1] != '..':\n                    stack.append('..')\n                \n        else:\n            stack.append(component)\n\n    if is_absolute:\n        normalized_path = '/' + '/'.join(stack[1:]) if len(stack) > 0 and stack[0] == '' else '/' + '/'.join(stack) if len(stack) > 0 else '/'\n        if normalized_path != '/' and normalized_path.endswith('/'):\n            normalized_path = normalized_path[:-1]\n        return normalized_path\n            \n    else:\n        normalized_path = '/'.join(stack)\n        if normalized_path != '/' and normalized_path.endswith('/'):\n            normalized_path = normalized_path[:-1]\n        return normalized_path", "passed": false, "failures": ["'/a//b/./c/../' -> '/a/b', expected '/a/b/'", "'../../x' -> 'x', expected '../../x'", "'a/./b/./c/' -> 'a/b/c', expected 'a/b/c/'", "'a/../../..' -> '', expected '../../'", "'a/../..' -> '..', expected '../'"]}]}
{"ts": 1761278818.81498, "problem": "parse_csv_line", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 0, "pass_at_k": 0.0, "history": [{"code": "from typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n    \"\"\"Parse a single CSV line into fields.\n\n    Handles:\n    - Empty line -> ['']\n    - Comma separated values\n    - Quoted values\n    - Double-double quotes inside quoted values\n    - Leading/trailing spaces inside and outside quotes\n    \"\"\"\n    if not line:\n        return ['']\n\n    fields = []\n    in_quote = False\n    current_field = ''\n\n    for i, char in enumerate(line):\n        if char == '\"':\n            if in_quote:\n                if i + 1 < len(line) and line[i + 1] == '\"':\n                    current_field += '\"'\n                    i += 1  # Skip the next quote\n                else:\n                    in_quote = False\n            else:\n                in_quote = True\n        elif char == ',' and not in_quote:\n            fields.append(current_field)\n            current_field = ''\n        else:\n            current_field += char\n\n    fields.append(current_field)\n    return fields", "passed": false, "failures": ["'\"a\"\"b\",c' -> ['a\"b,c'], expected ['a\"b', 'c']"]}]}
{"ts": 1761278834.457452, "problem": "sudoku_is_valid", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\n\ndef sudoku_is_valid(board: List[List[str]]) -> bool:\n    \"\"\"\n    Check if a partially filled 9x9 Sudoku board is valid.\n\n    Args:\n        board: A 9x9 Sudoku board represented as a list of lists of strings.\n\n    Returns:\n        True if the board is valid, False otherwise.\n        Handles edge cases where the board contains only '.' or '1'-'9'.\n    \"\"\"\n\n    # Check rows\n    for row in board:\n        seen = set()\n        for cell in row:\n            if cell != '.':\n                if cell in seen:\n                    return False\n                seen.add(cell)\n\n    # Check columns\n    for col in range(9):\n        seen = set()\n        for row in range(9):\n            cell = board[row][col]\n            if cell != '.':\n                if cell in seen:\n                    return False\n                seen.add(cell)\n\n    # Check 3x3 boxes\n    for box_row in range(3):\n        for box_col in range(3):\n            seen = set()\n            for row in range(box_row * 3, box_row * 3 + 3):\n                for col in range(box_col * 3, box_col * 3 + 3):\n                    cell = board[row][col]\n                    if cell != '.':\n                        if cell in seen:\n                            return False\n                        seen.add(cell)\n\n    return True", "passed": true, "failures": []}]}
{"ts": 1761278849.151406, "problem": "top_k_frequent", "model": {"provider": "google", "model": "gemini-2.0-flash", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\nfrom collections import Counter\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Return the k most frequent integers in nums.\n    If frequencies tie, break ties by smaller integer first.\n    Output length must be exactly k.\n    Raise ValueError if k < 1 or k > number of unique elements.\n\n    Edge cases:\n    - k < 1: raise ValueError\n    - k > number of unique elements: raise ValueError\n    - nums is empty: return empty list if k is 0, raise ValueError otherwise\n    \"\"\"\n    if k < 1:\n        raise ValueError(\"k must be greater than or equal to 1\")\n\n    counts = Counter(nums)\n    unique_count = len(counts)\n\n    if k > unique_count:\n        raise ValueError(\"k must be less than or equal to the number of unique elements\")\n\n    sorted_nums = sorted(counts.keys(), key=lambda x: (-counts[x], x))\n    return sorted_nums[:k]", "passed": true, "failures": []}]}
{"ts": 1761278859.655051, "problem": "cosine_similarity", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\nimport math\n\ndef cosine_similarity(a: List[float], b: List[float]) -> float:\n    \"\"\"Compute cosine similarity between two vectors.\n    \n    Handled edge cases:\n    - Zero magnitude in either vector returns 0.0\n    - Unequal vector lengths raise ValueError\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must be of equal length.\")\n    \n    dot_product = sum(x * y for x, y in zip(a, b))\n    norm_a = math.sqrt(sum(x ** 2 for x in a))\n    norm_b = math.sqrt(sum(y ** 2 for y in b))\n    \n    if norm_a == 0 or norm_b == 0:\n        return 0.0\n    \n    return dot_product / (norm_a * norm_b)", "passed": true, "failures": []}]}
{"ts": 1761278869.297241, "problem": "evaluate_rpn", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\n\ndef evaluate_rpn(tokens: List[str]) -> int:\n    \"\"\"Evaluate Reverse Polish Notation expression.\n    \n    Handled edge cases:\n    - Empty input (raises ValueError)\n    - Too few operands for an operator (raises ValueError)\n    - Division by zero (raises ValueError)\n    - Invalid tokens (treated as invalid expression, raises ValueError)\n    \"\"\"\n    stack = []\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b)  # truncates toward zero\n    }\n    \n    for token in tokens:\n        if token in operators:\n            if len(stack) < 2:\n                raise ValueError(\"Insufficient operands for operation\")\n            b = stack.pop()\n            a = stack.pop()\n            try:\n                result = operators[token](a, b)\n            except ZeroDivisionError:\n                raise ValueError(\"Division by zero\")\n            stack.append(result)\n        else:\n            try:\n                stack.append(int(token))\n            except ValueError:\n                raise ValueError(f\"Invalid token: {token}\")\n    \n    if len(stack) != 1:\n        raise ValueError(\"Invalid expression: too many operands\")\n    \n    return stack[0]", "passed": true, "failures": []}]}
{"ts": 1761278880.830699, "problem": "int_to_roman", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def int_to_roman(n: int) -> str:\n    \"\"\"\n    Convert an integer to Roman numerals (1..3999).\n    \n    Handled edge cases:\n    - Raises ValueError if n is not in 1..3999.\n    - Handles subtractive notation (e.g., IV for 4, IX for 9).\n    - Handles all values up to 3999 (MMMCMXCIX).\n    \"\"\"\n    if not 1 <= n <= 3999:\n        raise ValueError(\"n must be between 1 and 3999\")\n    \n    val_to_roman = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    result = []\n    for val, roman in val_to_roman:\n        while n >= val:\n            result.append(roman)\n            n -= val\n    return ''.join(result)", "passed": true, "failures": []}]}
{"ts": 1761278890.336305, "problem": "is_palindrome_sentence", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def is_palindrome_sentence(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome ignoring non-alphanumeric characters and case.\n    \n    Handled edge cases:\n    - Empty string or string with no alphanumeric characters (considered palindrome)\n    - Mixed case alphanumeric characters\n    - Strings with only non-alphanumeric characters\n    - Strings with leading/trailing non-alphanumeric characters\n    \n    Args:\n        s: Input string to check for palindrome.\n        \n    Returns:\n        bool: True if the alphanumeric characters form a palindrome (case-insensitive), False otherwise.\n    \"\"\"\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from the left\n        while left < right and not s[left].isalnum():\n            left += 1\n        # Skip non-alphanumeric characters from the right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if left < right:\n            if s[left].lower() != s[right].lower():\n                return False\n            left += 1\n            right -= 1\n    \n    return True", "passed": true, "failures": []}]}
{"ts": 1761278901.608305, "problem": "merge_intervals", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List, Tuple\n\ndef merge_intervals(intervals: List[Tuple[int,int]]) -> List[Tuple[int,int]]:\n    \"\"\"\n    Merge overlapping intervals and return a list sorted by start.\n    \n    Handled edge cases:\n    - Empty input list\n    - Single interval input\n    - Non-overlapping intervals\n    - Intervals contained within others\n    - Adjacent intervals (e.g., (1, 2) and (2, 3))\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Sort intervals based on the start value\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = []\n    current_start, current_end = intervals[0]\n    \n    for start, end in intervals[1:]:\n        if start <= current_end:\n            # Overlapping or adjacent intervals, merge them\n            current_end = max(current_end, end)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = start, end\n    \n    # Add the last merged interval\n    merged.append((current_start, current_end))\n    \n    return merged", "passed": true, "failures": []}]}
{"ts": 1761278915.604786, "problem": "min_window_substring", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "def min_window_substring(s: str, t: str) -> str:\n    \"\"\"\n    Return the smallest substring of s containing all characters of t (with multiplicity).\n    Handled edge cases:\n    - t is empty: return empty string\n    - s is shorter than t: return empty string\n    - no valid window: return empty string\n    - case sensitivity: assumes ASCII, case matters\n    - multiplicity: counts must match or exceed t's counts\n    \"\"\"\n    if not t or len(s) < len(t):\n        return \"\"\n    \n    from collections import defaultdict\n    \n    # Frequency map for t\n    t_counts = defaultdict(int)\n    for char in t:\n        t_counts[char] += 1\n    required = len(t_counts)\n    \n    # Sliding window variables\n    left = 0\n    formed = 0\n    window_counts = defaultdict(int)\n    result = (float('inf'), None, None)  # (length, left, right)\n    \n    for right, char in enumerate(s):\n        if char in t_counts:\n            window_counts[char] += 1\n            if window_counts[char] == t_counts[char]:\n                formed += 1\n        \n        # Try to contract the window from the left\n        while left <= right and formed == required:\n            # Update result if smaller window is found\n            if right - left + 1 < result[0]:\n                result = (right - left + 1, left, right)\n            \n            left_char = s[left]\n            if left_char in t_counts:\n                window_counts[left_char] -= 1\n                if window_counts[left_char] < t_counts[left_char]:\n                    formed -= 1\n            left += 1\n    \n    return s[result[1]: result[2] + 1] if result[0] != float('inf') else \"\"", "passed": true, "failures": []}]}
{"ts": 1761278925.3908732, "problem": "normalize_path", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 0, "pass_at_k": 0.0, "history": [{"code": "def normalize_path(path: str) -> str:\n    \"\"\"\n    Normalize a Unix-style path by resolving '.', '..', and redundant slashes.\n    \n    Handled edge cases:\n    - Multiple consecutive slashes.\n    - Relative paths with leading '..'.\n    - Absolute paths with '..' at root.\n    - Trailing slashes (preserved only for root).\n    - Empty path (returns '.').\n    \"\"\"\n    if not path:\n        return '.'\n    \n    is_absolute = path.startswith('/')\n    segments = []\n    \n    for segment in path.split('/'):\n        if segment == '' or segment == '.':\n            continue\n        elif segment == '..':\n            if segments:\n                if segments[-1] != '..':\n                    segments.pop()\n                else:\n                    if not is_absolute:\n                        segments.append(segment)\n            else:\n                if not is_absolute:\n                    segments.append(segment)\n        else:\n            segments.append(segment)\n    \n    normalized = '/'.join(segments)\n    \n    if is_absolute:\n        normalized = '/' + normalized\n    elif not normalized:\n        return '.'\n    \n    # Handle trailing slash for root case\n    if path.endswith('/') and normalized == '/':\n        return '/'\n    \n    return normalized", "passed": false, "failures": ["'/a//b/./c/../' -> '/a/b', expected '/a/b/'", "'a/./b/./c/' -> 'a/b/c', expected 'a/b/c/'", "'a/../../..' -> '../..', expected '../../'", "'a/../..' -> '..', expected '../'", "'' -> '.', expected ''"]}]}
{"ts": 1761278944.583665, "problem": "parse_csv_line", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n    \"\"\"Parse a CSV line into fields according to RFC 4180 subset rules.\n    \n    Handled edge cases:\n    - Empty line returns ['']\n    - Quoted fields containing commas and escaped quotes\n    - Mixed quoted/unquoted fields\n    - Preserves spaces outside quotes\n    - Handles consecutive commas as empty fields\n    \"\"\"\n    fields = []\n    current_field = []\n    in_quotes = False\n    \n    i = 0\n    while i < len(line):\n        char = line[i]\n        \n        if char == '\"':\n            if in_quotes:\n                # Check for escaped quote\n                if i + 1 < len(line) and line[i+1] == '\"':\n                    current_field.append('\"')\n                    i += 1  # skip next quote\n                else:\n                    in_quotes = False\n            else:\n                in_quotes = True\n        elif char == ',' and not in_quotes:\n            fields.append(''.join(current_field))\n            current_field = []\n        else:\n            current_field.append(char)\n        i += 1\n    \n    # Add the last field\n    fields.append(''.join(current_field))\n    \n    # Handle empty line case\n    if not line:\n        return ['']\n    \n    return fields", "passed": true, "failures": []}]}
{"ts": 1761278957.67075, "problem": "sudoku_is_valid", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\n\ndef sudoku_is_valid(board: List[List[str]]) -> bool:\n    \"\"\"Check if the given Sudoku board is valid.\n    \n    Handled edge cases:\n    - Board not 9x9\n    - Invalid characters (not '.' or '1'-'9')\n    - Duplicates in rows, columns, or 3x3 boxes\n    \"\"\"\n    # Check board dimensions\n    if len(board) != 9 or any(len(row) != 9 for row in board):\n        return False\n    \n    # Check rows\n    for row in board:\n        seen = set()\n        for num in row:\n            if num != '.':\n                if num in seen or not num.isdigit() or not (1 <= int(num) <= 9):\n                    return False\n                seen.add(num)\n    \n    # Check columns\n    for col in range(9):\n        seen = set()\n        for row in range(9):\n            num = board[row][col]\n            if num != '.':\n                if num in seen:\n                    return False\n                seen.add(num)\n    \n    # Check 3x3 boxes\n    for box_row in range(0, 9, 3):\n        for box_col in range(0, 9, 3):\n            seen = set()\n            for row in range(box_row, box_row + 3):\n                for col in range(box_col, box_col + 3):\n                    num = board[row][col]\n                    if num != '.':\n                        if num in seen:\n                            return False\n                        seen.add(num)\n    \n    return True", "passed": true, "failures": []}]}
{"ts": 1761278969.837512, "problem": "top_k_frequent", "model": {"provider": "huggingface", "model": "deepseek-ai/DeepSeek-V3-0324", "temperature": 0.6}, "strategy": "cot", "k": 1, "successes": 1, "pass_at_k": 1.0, "history": [{"code": "from typing import List\nimport heapq\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"Return the k most frequent integers in nums, with ties broken by smaller integer.\n    \n    Handled edge cases:\n    - k < 1 or k > number of unique elements (raises ValueError)\n    - Empty input list (implicitly handled by the above)\n    - All elements are the same\n    - Ties in frequency\n    \"\"\"\n    if k < 1:\n        raise ValueError(\"k must be at least 1\")\n    \n    frequency = {}\n    for num in nums:\n        frequency[num] = frequency.get(num, 0) + 1\n    \n    if k > len(frequency):\n        raise ValueError(\"k cannot be greater than the number of unique elements\")\n    \n    # Use a min-heap of size k, storing tuples of (-frequency, num) to simulate max-heap\n    heap = []\n    for num, count in frequency.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (count, num))\n        else:\n            # If current count is higher than the smallest in heap, replace\n            if count > heap[0][0] or (count == heap[0][0] and num < heap[0][1]):\n                heapq.heappop(heap)\n                heapq.heappush(heap, (count, num))\n    \n    # Extract the elements from the heap and sort by frequency (desc) and num (asc)\n    result = [num for count, num in sorted(heap, key=lambda x: (-x[0], x[1]))]\n    return result", "passed": true, "failures": []}]}
